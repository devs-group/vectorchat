---
description: 
globs: 
alwaysApply: true
---
# Rules for VectorChat Go Project Structure

## Project Structure

```
ğŸ“ cmd                        # Entry point of the application
â””â”€â”€ ğŸ“„ main.go                # Main function â€“ bootstraps the app, sets up services, starts server

ğŸ“ pkg                        # Application code (shared across services/packages)
â”œâ”€â”€ ğŸ“ api                    # HTTP handlers and route definitions
â”œâ”€â”€ ğŸ“ auth                   # Authentication logic
â”‚   â””â”€â”€ ğŸ“„ middleware.go      # Middleware to protect routes, check tokens, etc.
â”œâ”€â”€ ğŸ“ services               # Core chat logic / business layer
â”œâ”€â”€ ğŸ“ db                     # Database-related code (data access layer)
â”‚   â”œâ”€â”€ ğŸ“ migrations         # DB migration files (SQL or migration tool files)
â”œâ”€â”€ ğŸ“ errors                 # Centralized error types and helpers
â”‚   â””â”€â”€ ğŸ“„ errors.go          # Custom error types, wrappers, mappers
â””â”€â”€ ğŸ“ vectorize              # Vectorization / embedding logic (e.g., NLP or ML)
    â””â”€â”€ ğŸ“„ vectorizer.go      # Logic for converting text and files into vector representations
```

## Naming Conventions

### Package Names
- Use short, lowercase, single-word names
- Avoid underscores or mixedCaps
- Examples: `api`, `chat`, `db`, `errors`, `auth`

### File Names
- Use snake_case for file names
- Include the purpose in the name: `chat_handler.go`, `user_store.go`
- Group related functionality with consistent prefixes
- For handlers, use `[feature]_handler.go`: `chat_handler.go`
- For stores, use `[entity]_store.go`: `user_store.go`

### Type Names
- Use PascalCase (UpperCamelCase) for exported types
- Suffix with purpose: `ChatHandler`, `UserStore`, `OAuthConfig`
- Internal/unexported types should be camelCase and start with lowercase

### Function/Method Names
- Use PascalCase for exported functions: `RegisterRoutes`, `NewChatHandler`
- Prefix constructors with `New`: `NewChatHandler`, `NewOAuthHandler`
- Use camelCase for unexported functions: `getGitHubEmails` 
- HTTP handlers follow the pattern `[METHOD]_[Resource]`: `POST_UploadFile`, `GET_ChatFiles`

## Logic Placement Rules

### `/cmd/main.go`
- Application entrypoint
- Initializes dependencies and configuration
- Sets up services, database connections, and web server
- Defines wire-up logic but keeps it minimal

### `/pkg/api/`
- **Contains**: HTTP handlers, route registration, request/response handling
- **Responsibilities**:
  - Define API routes and HTTP handlers
  - Parse request data and validate inputs
  - Call appropriate service methods
  - Format and return responses
  - HTTP-specific error handling
- **Does not contain**: Business logic, database operations

### `/pkg/services`
- **Contains**: Core business logic
- **Responsibilities**: 
  - Holding golang business logic
  - Handles specific logic for creation
  - Any third party interactions

### `/pkg/db`
- **Contains**: Database operations for entities
- **Responsibilities**: 
  - Only handling db errors and making db queries
- **Dependencies**: Database connection

### `/pkg/errors/errors.go`
- **Contains**: Custom error types and error handling utilities
- **Types**: Custom error types with appropriate methods
- **Constants**: Common error variables like `ErrUserNotFound`, `ErrNoDocumentsFound`
- **Functions**: Error wrapping, checking, and HTTP status mapping

### `/pkg/auth/middleware.go`
- **Contains**: Authentication middleware for protecting routes
- **Functions**: Middleware for session validation, API key validation
- **Dependencies**: User store, session store

### `/pkg/vectorize/vectorizer.go`
- **Contains**: Logic for converting text/files to vector embeddings
- **Type**: `Vectorizer` struct
- **Methods**: File processing, text vectorization, similarity search
- **Dependencies**: Vector database client, embedding model

## Error Handling Rules

1. Use custom error types defined in `/pkg/errors/errors.go`
2. Check errors with `apperrors.Is(err, apperrors.ErrorType)` rather than direct comparison
3. In HTTP handlers, map errors to appropriate HTTP status codes
4. Return structured error responses using `fiber.Map` with consistent fields
5. Log errors at appropriate levels before returning to the client

## Dependency Injection Rules

1. Services and handlers should receive their dependencies via constructor functions
2. Use clear parameter names in constructors to show required dependencies
3. Follow pattern: `func New[Type](mdc:dependency1, dependency2) *[Type]`
4. Store dependencies as fields in the struct

## Route Registration Rules

1. Each handler type has its own `RegisterRoutes(app *fiber.App)` method
2. Group related routes under a common prefix: `app.Group("/chat")`, `app.Group("/auth")`
3. Route names should be descriptive and follow REST conventions
4. HTTP methods in handler names should be capitalized: `POST_`, `GET_`, `DELETE_`