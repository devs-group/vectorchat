---
description: 
globs: 
alwaysApply: true
---
# .cursor Rules for VectorChat Go Project Structure

## Project Structure

```
ğŸ“ cmd                        # Entry point of the application
â””â”€â”€ ğŸ“„ main.go                # Main function â€“ bootstraps the app, sets up services, starts server

ğŸ“ pkg                        # Application code (shared across services/packages)
â”œâ”€â”€ ğŸ“ api                    # HTTP handlers and route definitions
â”‚   â”œâ”€â”€ ğŸ“„ chat_handler.go    # Handlers for chat-related HTTP routes 
â”‚   â””â”€â”€ ğŸ“„ oauth_handler.go   # OAuth-related handlers (e.g., login with GitHub)
â”œâ”€â”€ ğŸ“ auth                   # Authentication logic
â”‚   â””â”€â”€ ğŸ“„ middleware.go      # Middleware to protect routes, check tokens, etc.
â”œâ”€â”€ ğŸ“ chat                   # Core chat logic / business layer
â”‚   â””â”€â”€ ğŸ“„ service.go         # Core use cases and orchestration of chat feature
â”œâ”€â”€ ğŸ“ db                     # Database-related code (data access layer)
â”‚   â”œâ”€â”€ ğŸ“ migrations         # DB migration files (SQL or migration tool files)
â”‚   â”œâ”€â”€ ğŸ“„ chat_store.go      # DB queries for chat (e.g., saving messages, getting history)
â”‚   â””â”€â”€ ğŸ“„ user_store.go      # DB queries for user info (e.g., find user by email)
â”œâ”€â”€ ğŸ“ errors                 # Centralized error types and helpers
â”‚   â””â”€â”€ ğŸ“„ errors.go          # Custom error types, wrappers, mappers
â””â”€â”€ ğŸ“ vectorize              # Vectorization / embedding logic (e.g., NLP or ML)
    â””â”€â”€ ğŸ“„ vectorizer.go      # Logic for converting text and files into vector representations
```

## Naming Conventions

### Package Names
- Use short, lowercase, single-word names
- Avoid underscores or mixedCaps
- Examples: `api`, `chat`, `db`, `errors`, `auth`

### File Names
- Use snake_case for file names
- Include the purpose in the name: `chat_handler.go`, `user_store.go`
- Group related functionality with consistent prefixes
- For handlers, use `[feature]_handler.go`: `chat_handler.go`
- For stores, use `[entity]_store.go`: `user_store.go`

### Type Names
- Use PascalCase (UpperCamelCase) for exported types
- Suffix with purpose: `ChatHandler`, `UserStore`, `OAuthConfig`
- Internal/unexported types should be camelCase and start with lowercase

### Function/Method Names
- Use PascalCase for exported functions: `RegisterRoutes`, `NewChatHandler`
- Prefix constructors with `New`: `NewChatHandler`, `NewOAuthHandler`
- Use camelCase for unexported functions: `getGitHubEmails` 
- HTTP handlers follow the pattern `[METHOD]_[Resource]`: `POST_UploadFile`, `GET_ChatFiles`

## Logic Placement Rules

### `/cmd/main.go`
- Application entrypoint
- Initializes dependencies and configuration
- Sets up services, database connections, and web server
- Defines wire-up logic but keeps it minimal

### `/pkg/api/`
- **Contains**: HTTP handlers, route registration, request/response handling
- **Responsibilities**:
  - Define API routes and HTTP handlers
  - Parse request data and validate inputs
  - Call appropriate service methods
  - Format and return responses
  - HTTP-specific error handling
- **Does not contain**: Business logic, database operations

### `/pkg/api/chat_handler.go`
- **Contains**: All chat-related HTTP route handlers
- **Type**: `ChatHandler` struct with appropriate dependencies
- **Methods**:
  - `RegisterRoutes(app *fiber.App)`: Registers all chat-related routes
  - HTTP Handlers following pattern: `[METHOD]_[Resource]`
  - Example: `POST_UploadFile`, `DELETE_ChatFile`, `GET_ChatFiles`
- **Dependencies**: Injected in constructor (`NewChatHandler`)
  - Chat service, stores, configuration values

### `/pkg/api/oauth_handler.go`
- **Contains**: All authentication and OAuth-related HTTP route handlers
- **Type**: `OAuthHandler` struct with OAuth config and dependencies
- **Methods**:
  - `RegisterRoutes(app *fiber.App)`: Registers all auth-related routes
  - Auth-specific handlers: `GET_GitHubLogin`, `GET_GitHubCallback`, etc.
  - Session management: `GET_Session`, `POST_Logout`
  - API key management: `POST_GenerateAPIKey`, `GET_ListAPIKeys`, etc.
- **Dependencies**: OAuth config, session store, user store

### `/pkg/chat/service.go`
- **Contains**: Core chat business logic
- **Type**: `ChatService` struct
- **Methods**: 
  - Core chat operations: `ChatWithID`, `AddFile`, etc.
  - File processing logic
  - Vector search/query operations
- **Dependencies**: Vectorizer, stores

### `/pkg/db/chat_store.go`
- **Contains**: Database operations for chat entities
- **Type**: `ChatStore` struct
- **Methods**:
  - CRUD operations for chat messages and documents
  - `GetDocumentsByPrefix`, `DeleteDocument`, etc.
- **Dependencies**: Database connection

### `/pkg/db/user_store.go`
- **Contains**: Database operations for user entities
- **Type**: `UserStore` struct
- **Methods**:
  - User CRUD operations: `FindUserByEmail`, `FindUserByID`, `CreateUser`
  - API key operations: `CreateAPIKey`, `GetAPIKeys`, `RevokeAPIKey`
- **Dependencies**: Database connection

### `/pkg/errors/errors.go`
- **Contains**: Custom error types and error handling utilities
- **Types**: Custom error types with appropriate methods
- **Constants**: Common error variables like `ErrUserNotFound`, `ErrNoDocumentsFound`
- **Functions**: Error wrapping, checking, and HTTP status mapping

### `/pkg/auth/middleware.go`
- **Contains**: Authentication middleware for protecting routes
- **Functions**: Middleware for session validation, API key validation
- **Dependencies**: User store, session store

### `/pkg/vectorize/vectorizer.go`
- **Contains**: Logic for converting text/files to vector embeddings
- **Type**: `Vectorizer` struct
- **Methods**: File processing, text vectorization, similarity search
- **Dependencies**: Vector database client, embedding model

## Error Handling Rules

1. Use custom error types defined in `/pkg/errors/errors.go`
2. Check errors with `apperrors.Is(err, apperrors.ErrorType)` rather than direct comparison
3. In HTTP handlers, map errors to appropriate HTTP status codes
4. Return structured error responses using `fiber.Map` with consistent fields
5. Log errors at appropriate levels before returning to the client

## Dependency Injection Rules

1. Services and handlers should receive their dependencies via constructor functions
2. Use clear parameter names in constructors to show required dependencies
3. Follow pattern: `func New[Type](mdc:dependency1, dependency2) *[Type]`
4. Store dependencies as fields in the struct

## Route Registration Rules

1. Each handler type has its own `RegisterRoutes(app *fiber.App)` method
2. Group related routes under a common prefix: `app.Group("/chat")`, `app.Group("/auth")`
3. Route names should be descriptive and follow REST conventions
4. HTTP methods in handler names should be capitalized: `POST_`, `GET_`, `DELETE_`